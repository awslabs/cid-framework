AWSTemplateFormatVersion: '2010-09-09'
Description: Organization data collections.
Parameters:
  ManagementRoleName:
    Type: String
    Description: The name of the IAM role that will be deployed in the management account which can retrieve AWS Organization data. KEEP THE SAME AS WHAT IS DEPLOYED INTO MANAGEMENT ACCOUNT
  ManagementAccountID:
    Type: String
    AllowedPattern: ([a-z0-9\-, ]*?$)
    Description: "(Ex: 123456789,098654321,789054312) List of Payer IDs you wish to collect data for. Can just be one Accounts"
  RolePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
Outputs:
  LambdaFunctionName:
    Value: !Ref LambdaFunction
  LambdaFunctionARN:
    Description: Lambda function ARN
    Value: !GetAtt LambdaFunction.Arn
    Export:
      Name: AccountCollectorLambdaARN
Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${RolePrefix}account-collector-LambdaRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: "AssumeManagementRole"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${ManagementRoleName}" # Need to assume a Read role in all Management Accounts
        - PolicyName: "CloudWatch"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "logs:DescribeLogStreams"
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: "Need explicit name to identify role actions"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${RolePrefix}account-collector-Lambda'
      Description: "Lambda function to retrieve the account list"
      Runtime: python3.8
      Architectures: [arm64]
      Code:
          ZipFile: |
            import os
            import json
            import logging
            import boto3
            from botocore.exceptions import BotoCoreError
            from botocore.exceptions import ClientError

            ROLE_NAME = os.environ['ROLENAME']
            MANAGEMENT_ACCOUNT_IDS = os.environ['MANAGEMENT_ACCOUNT_IDS']
            MODULE_NAME = "account-collector"

            logger = logging.getLogger(__name__)
            logger.setLevel(getattr(logging, os.environ.get('LOG_LEVEL', 'INFO').upper(), logging.INFO))

            # Helper Exception classes
            class CidError(Exception):
                pass
            class CidNonFatalError(CidError):
                pass
            class CidFatalError(CidError):
                pass

            def lambda_handler(event, context):
                logger.info(f"Incoming event: {event}")
                key = "Type"
                try:
                    accounts = main(event[key], MANAGEMENT_ACCOUNT_IDS, ROLE_NAME)
                    
                except KeyError as e:
                    logger.error(f"Lambda event parameter '{key}' not defined (fatal)")
                    raise RuntimeError(f"(MissingParameterError) Lambda event missing '{key}' parameter in {MODULE_NAME} module")
                    
                except CidError as e:
                    logger.error(f"CID error: {e} (fatal)")
                    raise RuntimeError(f"(CidError) in {MODULE_NAME} module")
                    
                except Exception as e:
                    logger.error(f"Unhandled {type(e).__name__} exception: {e}")
                    raise RuntimeError(f"(UnhandledExceptionError) in {MODULE_NAME} module")
                    
                return {
                    'statusCode': 200,
                    'accountList': accounts
                }

            def main(module_type, management_accounts, role_name):
                logger.info(f"Processing for type '{module_type}' and using role '{role_name}'")
                account_list = []
                for payer_id in [r.strip() for r in management_accounts.split(',')]:
                    if (module_type.upper()) == 'MULTI':
                        try:
                            for account in iterate_accounts(role_name, management_accounts):
                                if account['Status'] != 'ACTIVE':
                                  logger.info(f"Account {account['Id']} is not active")
                                  continue
                                account_data = populate_account(account.get('Id'), account.get('Name'), management_accounts)
                                account_list.append({"account" : json.dumps(account_data)})
                        except CidNonFatalError as exc:
                            logger.warning(f"Payer account '{payer_id}' encountered access issues")
                    else:
                        account_data = populate_account(payer_id, payer_id, payer_id)
                        account_list.append({"account" : json.dumps(account_data)})

                if len(account_list) == 0:
                    raise CidFatalError("No accounts were collected")
                
                logger.info(f"Successfully found {len(account_list)} accounts")
                logger.debug(f"Successfully found accounts: {json.dumps(account_list)}")
                return account_list

            def iterate_accounts(role_name, payer_id):
                logger.info(f"Iterating accounts for payer '{payer_id}'")
                try:
                    client = get_client_with_role(role_name, payer_id, region="us-east-1", service="organizations") #This MUST be us-east-1 regardless of lambda region
                    for page in client.get_paginator("list_accounts").paginate():
                        for account in page['Accounts']:
                            yield account
                            
                except CidNonFatalError as e:
                    raise e

            def populate_account(account_id, account_name, payer_id):
              account_data = {}
              account_data['account_id'] = account_id
              account_data['account_name'] = account_name
              account_data['payer_id'] = payer_id
              return account_data

            def get_client_with_role(role_name, account_id, service, region):
                logger.debug(f"Getting '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'")
                try:
                    credentials = boto3.client('sts').assume_role(
                        RoleArn=f"arn:aws:iam::{account_id}:role/{role_name}",
                        RoleSessionName="data_collection"
                    )['Credentials']
                    logger.debug(f"Successfully assumed role, now getting client")
                    client = boto3.client(
                        service,
                        region_name = region,
                        aws_access_key_id=credentials['AccessKeyId'],
                        aws_secret_access_key=credentials['SecretAccessKey'],
                        aws_session_token=credentials['SessionToken'],
                    )
                    logger.debug(f"Successfully got client with assumed role")
                    return client
                    
                except BotoCoreError as e:
                    raise get_non_fatal_exception(e, f"BotoCore exception: '{e}' when getting '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'", "(BotoCore) exception")    

                except ClientError as e:
                    raise get_non_fatal_exception(e, f"(BotoCoreClient) exception: '{e}' when getting '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'", "(BotoCoreClient) exception")    

            def get_non_fatal_exception(e, log_msg, e_msg):
                logger.warning(log_msg)
                return CidNonFatalError(e_msg)
      Handler: 'index.lambda_handler'
      MemorySize: 2688
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          ROLENAME: !Ref ManagementRoleName
          MANAGEMENT_ACCOUNT_IDS: !Ref ManagementAccountID
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89 # Lambda functions should be deployed inside a VPC
            reason: "No need for VPC in this case"
          - id: W92 #  Lambda functions should define ReservedConcurrentExecutions to reserve simultaneous executions
            reason: "No need for simultaneous execution"