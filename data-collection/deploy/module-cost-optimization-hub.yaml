AWSTemplateFormatVersion: "2010-09-09"
Description: Retrieves AWS Cost Optimization Hub Data across AWS organization
Parameters:
  DatabaseName:
    Type: String
    Description: Name of the Athena database to be created to hold lambda information
    Default: optimization_data
  DestinationBucket:
    Type: String
    Description: Name of the S3 Bucket that exists or needs to be created to hold information
    AllowedPattern: (?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$)
  DestinationBucketARN:
    Type: String
    Description: ARN of the S3 Bucket that exists or needs to be created to hold information
  ManagementRoleName:
    Type: String
    Description: The name of the IAM role that will be deployed in the management account which can retrieve AWS Organization data. KEEP THE SAME AS WHAT IS DEPLOYED INTO MANAGEMENT ACCOUNT
  CFDataName:
    Type: String
    Description: The name of what this cf is doing.
    Default: cost-optimization-hub
  GlueRoleARN:
    Type: String
    Description: Arn for the Glue Crawler role
  Schedule:
    Type: String
    Description: EventBridge Schedule to trigger the data collection
    Default: "rate(14 days)"
  ResourcePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
  LambdaAnalyticsARN:
    Type: String
    Description: Arn of lambda for Analytics
  AccountCollectorLambdaARN:
    Type: String
    Description: Arn of the Account Collector Lambda
  CodeBucket:
    Type: String
    Description: Source code bucket
  StepFunctionTemplate:
    Type: String
    Description: S3 key to the JSON template for the StepFunction
  StepFunctionExecutionRoleARN:
    Type: String
    Description: Common role for Step Function execution
  SchedulerExecutionRoleARN:
    Type: String
    Description: Common role for module Scheduler execution

Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ResourcePrefix}${CFDataName}-LambdaRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: !Sub "${CFDataName}-ManagementAccount-LambdaRole"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${ManagementRoleName}" # Need to assume a Read role in all Management accounts
        - PolicyName: "S3-Access"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "s3:PutObject"
                  - "s3:GetObject"
                  - "s3:PutObjectAcl"
                  - "s3:DeleteObject"
                Resource:
                  - !Sub "${DestinationBucketARN}/*"
              - Effect: "Allow"
                Action:
                  - "s3:ListBucket"
                Resource:
                  - !Sub "${DestinationBucketARN}"
        - PolicyName: !Sub "${CFDataName}-detail-StateMachineExecution"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "states:StartExecution"
                Resource: !Sub "arn:aws:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${ResourcePrefix}${CFDataName}-detail-StateMachine"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: "Need explicit name to identify role actions"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ResourcePrefix}${CFDataName}-Lambda'
      Description: !Sub "Lambda function to retrieve ${CFDataName}"
      Runtime: python3.10
      Architectures: [x86_64]
      Code:
        ZipFile: |
          import os
          import json
          import time
          import logging
          from functools import partial
          from datetime import date, datetime

          # update boto3 version
          import sys
          from pip._internal import main
          main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
          sys.path.insert(0,'/tmp/')

          import boto3 #pylint: disable=wrong-import-position
          from botocore.config import Config

          logger = logging.getLogger()
          # Create a new handler here because downloading the updated boto3 affects the
          # default Lambda logging handler such that only Warning and Error are logged.
          for h in logger.handlers:
            logger.removeHandler(h)
          h = logging.StreamHandler(sys.stdout)
          h.setFormatter(logging.Formatter('[%(levelname)s] %(message)s'))
          logger.addHandler(h)
          logger.setLevel(getattr(logging, os.environ.get('LOG_LEVEL', 'INFO').upper(), logging.INFO))

          BUCKET_NAME = os.environ['BUCKET_NAME']
          ROLENAME = os.environ['ROLENAME']
          PREFIX = os.environ['PREFIX']
          DETAIL_SM_ARN = os.environ['DETAIL_SM_ARN']
          TMP_FILE = "/tmp/data.json"
          TMP_FILE_BATCH = "/tmp/batch.csv"
          NEED_DETAILED = os.environ.get('NEED_DETAILED', 'true').lower() in ['true', '1', 'y', 'yes']
          RETRIES = int(os.environ.get('RETRIES', "10"))
          BOTO_CONFIG = Config(
              retries = {
                'max_attempts': RETRIES,
                'mode': 'standard'
            }
          )

          def to_json(obj):
              """json helper for date, time and data"""
              def _date_transformer(obj):
                  return obj.isoformat() if isinstance(obj, (date, datetime)) else None
              return json.dumps(obj, default=_date_transformer)

          def store_summary_to_s3(records, payer_id):
              """ Upload records to s3 """
              count = 0

              # Use two temp files, one for full summary records and one for batch processor data
              with open(TMP_FILE, "w", encoding='utf-8') as summary_file:
                  with open(TMP_FILE_BATCH, "w", encoding='utf-8') as batch_file:
                      batch_file.write('id,actionType\n')
                      for count, record in enumerate(records, start=1):
                          summary_file.write(to_json(record) + '\n')
                          rec_id = record.get('recommendationId')
                          actionType = record.get('actionType')
                          if rec_id and actionType:
                              batch_file.write(f'{rec_id},{actionType}\n')
              if not count:
                  logger.info(f"No records found")
                  return count

              s3 = boto3.client('s3')
              key = date.today().strftime(
                  f"{PREFIX}/{PREFIX}-summary-data/payer_id={payer_id}"
                  f"/year=%Y/month=%m/day=%d/%Y-%m-%d.json")
              s3.upload_file(TMP_FILE, BUCKET_NAME, key)
              logger.info(f'Uploaded {count} records to s3://{BUCKET_NAME}/{key}')

              key =  f"{PREFIX}/{PREFIX}-batch-data/payer_id={payer_id}/recommendations.csv"
              s3.upload_file(TMP_FILE_BATCH, BUCKET_NAME, key)

              return count, key

          def store_detail_to_s3(records, payer_id):
              """ Upload records to s3 """
              count = 0
              s3 = boto3.client('s3', config=BOTO_CONFIG)

              cur_date = date.today()
              # Each record will be a unique file named by the base64 recommendation id
              for count, record in enumerate(records, start=1):
                  s3_key = cur_date.strftime(
                      f'{PREFIX}/{PREFIX}-detail-data/payer_id={payer_id}'
                      f'/year=%Y/month=%m/day=%d/{record["recommendationId"]}.json'
                  )
                  s3.put_object(Body=to_json(record), Bucket=BUCKET_NAME, Key=s3_key)

              return count

          def get_detailed_recommendation(hub, rec):
            time.sleep(.25)
            try:
                res = hub.get_recommendation(recommendationId=rec['id'])
            except: #pylint: disable=bare-except
                # Ignore: The recommendation id appears to be ephemeral with the same recommendation sometimes getting a new id upon a later data run
                logger.info(f"Error getting recommendation details for {rec['id']}")
                return None
            res.pop('ResponseMetadata', None)
            res = conform_to_schema(res, 'currentResourceDetails', RECORD_TYPE_SCHEMAS)
            res = conform_to_schema(res, 'recommendedResourceDetails', RECORD_TYPE_SCHEMAS)
            return res

          def conform_to_schema(record, field, schema):
              """
              The API result for detail records will contain only a subset of the full potential schema for 2 resource-specific fields.
              Need to use a blank template of the full schema, transpose the result into it and save that full schema to the file
              to avoid potential issues with Hive when the bucket and partitions are rescanned to update the table in Athena.
              """
              field_data = record.get(field)
              record_type = list(field_data.keys())[0]
              schema[record_type] = field_data[record_type]
              record[field] = schema
              return record

          def iterate_paginated_results(client, function, search, params=None):
              yield from client.get_paginator(function).paginate(**(params or {})).search(search)

          def lambda_handler(event, context): #pylint: disable=unused-argument
              """ this lambda collects CostOptimizationHub data
              and must be called from the corresponding Step Function to orchestrate

              It can be called from two different modes, one for obtaining a summary
              of all recommendations and the other to get individual details of each recommendations
              """
              logger.info(f"Event data: {event}")
              account = event.get('account')
              batch_input = event.get('BatchInput')
              items = event.get('Items')
              if not (account or batch_input):
                  raise ValueError(
                      "Please do not trigger this Lambda manually."
                      "Find the corresponding state machine in Step Functions and Trigger from there."
                  )
              # Identify if this is invoked in summary vs. batch detail mode, via the event data present
              is_summary_mode = batch_input == None
              logger.info(f"Executing in {'summary' if is_summary_mode else 'detail'} mode flow")
              account = json.loads(account) if is_summary_mode else batch_input.get('account')
              account_id = account["account_id"]

              creds = boto3.client('sts').assume_role(
                  RoleArn=f"arn:aws:iam::{account_id}:role/{ROLENAME}",
                  RoleSessionName="cross_acct_lambda"
              )['Credentials']
              hub = boto3.client(
                  'cost-optimization-hub',
                  "us-east-1",  #can be only us-east-1
                  aws_access_key_id=creds['AccessKeyId'],
                  aws_secret_access_key=creds['SecretAccessKey'],
                  aws_session_token=creds['SessionToken'],
                  config=BOTO_CONFIG,
              )

              if is_summary_mode:
                  data_iterator = iterate_paginated_results(
                      client=hub,
                      function='list_recommendations',
                      search='items',
                      params=dict( #pylint: disable=R1735
                          includeAllRecommendations=True,
                      ),
                  )
                  count, rec_key = store_summary_to_s3(data_iterator, account_id)
                  sf = boto3.client('stepfunctions')
                  sf_input = {
                      "bucket": BUCKET_NAME,
                      "file": rec_key,
                      "account": account
                  }
                  sf_input = json.dumps(sf_input).replace('"', '\"') #need to escape the json for SF
                  sf.start_execution(stateMachineArn=DETAIL_SM_ARN, input=sf_input)
              elif (items and NEED_DETAILED):
                  data_iterator = map(
                      partial(get_detailed_recommendation, hub),
                      items.__iter__(),
                  )
                  count = store_detail_to_s3(data_iterator, account_id)
              else:
                  count = 0

              return {"status":"200","Recorded":f'"{count}"'}

          RECORD_TYPE_SCHEMAS = {
            "computeSavingsPlans": {
                "configuration": {"accountScope": "", "hourlyCommitment": "", "paymentOption": "", "term": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyCommitment": 0, "estimatedOnDemandCost": 0, "monthlySavingsPlansEligibleCost": 0, "savingsPercentage": 0}}
            },
            "ebsVolume": {
                "configuration": {"attachmentState": "", "performance": {"iops": 0, "throughput": 0}, "storage": {"sizeInGb": 0, "type": ""}},
                "costCalculation": {
                    "pricing": {"estimatedCostAfterDiscounts": 0,"estimatedCostBeforeDiscounts": 0,"estimatedDiscounts": {"otherDiscount": 0,"reservedInstancesDiscount": 0, "savingsPlansDiscount": 0},"estimatedNetUnusedAmortizedCommitments": 0},
                    "usages": [{"operation": "", "productCode": "", "unit": "", "usageAmount": 0, "usageType": ""}]
                }
            },
            "ec2AutoScalingGroup": {
                "configuration": {"instance": {"type": ""}},
                "costCalculation": {
                    "pricing": {"estimatedCostAfterDiscounts": 0,"estimatedCostBeforeDiscounts": 0,"estimatedDiscounts": {"otherDiscount": 0, "reservedInstancesDiscount": 0, "savingsPlansDiscount": 0},"estimatedNetUnusedAmortizedCommitments": 0},
                    "usages": [{"operation": "", "productCode": "", "unit": "", "usageAmount": 0, "usageType": ""}]
                }
            },
            "ec2Instance": {
                "configuration": {"instance": {"type": ""}},
                "costCalculation": {
                    "pricing": {"estimatedCostAfterDiscounts": 0,"estimatedCostBeforeDiscounts": 0,"estimatedDiscounts": {"otherDiscount": 0,"reservedInstancesDiscount": 0, "savingsPlansDiscount": 0},"estimatedNetUnusedAmortizedCommitments": 0},
                    "usages": [{"operation": "", "productCode": "", "unit": "", "usageAmount": 0, "usageType": ""}]
                }
            },
            "ec2InstanceSavingsPlans": {
                "configuration": {"accountScope": "", "hourlyCommitment": "", "instanceFamily": "", "paymentOption": "", "savingsPlansRegion": "", "term": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyCommitment": 0, "estimatedOnDemandCost": 0, "monthlySavingsPlansEligibleCost": 0, "savingsPercentage": 0}}
            },
            "ec2ReservedInstances": {
                "configuration": {"accountScope": "","currentGeneration": "","instanceFamily": "","instanceType": "","monthlyRecurringCost": "","normalizedUnitsToPurchase": "","numberOfInstancesToPurchase": "","offeringClass": "","paymentOption": "","platform": "","reservedInstancesRegion": "","service": "","sizeFlexEligible": "","tenancy": "","term": "","upfrontCost": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyAmortizedReservationCost": 0, "estimatedOnDemandCost": 0, "monthlyReservationEligibleCost": 0, "savingsPercentage": 0}}
            },
            "ecsService": {
                "configuration": {"compute": {"architecture": "", "memorySizeInMB": 123, "platform": "", "vCpu": 0}},
                "costCalculation": {
                    "pricing": {"estimatedCostAfterDiscounts": 0,"estimatedCostBeforeDiscounts": 0,"estimatedDiscounts": {"otherDiscount": 0,"reservedInstancesDiscount": 0, "savingsPlansDiscount": 0},"estimatedNetUnusedAmortizedCommitments": 0},
                    "usages": [{"operation": "", "productCode": "", "unit": "", "usageAmount": 0, "usageType": ""}]
                }
            },
            "elastiCacheReservedInstances": {
                "configuration": {"accountScope": "","currentGeneration": "","instanceFamily": "","instanceType": "","monthlyRecurringCost": "",
                    "normalizedUnitsToPurchase": "","numberOfInstancesToPurchase": "","paymentOption": "","reservedInstancesRegion": "","service": "",
                    "sizeFlexEligible": "","term": "","upfrontCost": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyAmortizedReservationCost": 0, "estimatedOnDemandCost": 0, "monthlyReservationEligibleCost": 0, "savingsPercentage": 0}}
            },
            "lambdaFunction": {
                "configuration": {"compute": {"architecture": "", "memorySizeInMB": 123, "platform": "", "vCpu": 0}},
                "costCalculation": {
                    "pricing": {"estimatedCostAfterDiscounts": 0,"estimatedCostBeforeDiscounts": 0,"estimatedDiscounts": {"otherDiscount": 0, "reservedInstancesDiscount": 0, "savingsPlansDiscount": 0},"estimatedNetUnusedAmortizedCommitments": 0},
                    "usages": [{"operation": "", "productCode": "", "unit": "", "usageAmount": 0, "usageType": ""}]
                }
            },
            "openSearchReservedInstances": {
                "configuration": {"accountScope": "","currentGeneration": "","instanceType": "","monthlyRecurringCost": "","normalizedUnitsToPurchase": "","numberOfInstancesToPurchase": "","paymentOption": "","reservedInstancesRegion": "","service": "","sizeFlexEligible": "","term": "","upfrontCost": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyAmortizedReservationCost": 0, "estimatedOnDemandCost": 0, "monthlyReservationEligibleCost": 0, "savingsPercentage": 0}}
            },
            "rdsReservedInstances": {
                "configuration": {"accountScope": "","currentGeneration": "","databaseEdition": "","databaseEngine": "","deploymentOption": "","instanceFamily": "","instanceType": "","licenseModel": "","monthlyRecurringCost": "","normalizedUnitsToPurchase": "","numberOfInstancesToPurchase": "","paymentOption": "","reservedInstancesRegion": "","service": "","sizeFlexEligible": "","term": "","upfrontCost": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyAmortizedReservationCost": 0, "estimatedOnDemandCost": 0, "monthlyReservationEligibleCost": 0, "savingsPercentage": 0}}
            },
            "redshiftReservedInstances": {
                "configuration": {"accountScope": "","currentGeneration": "","instanceFamily": "","instanceType": "","monthlyRecurringCost": "","normalizedUnitsToPurchase": "","numberOfInstancesToPurchase": "","paymentOption": "","reservedInstancesRegion": "","service": "","sizeFlexEligible": "","term": "","upfrontCost": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyAmortizedReservationCost": 0, "estimatedOnDemandCost": 0, "monthlyReservationEligibleCost": 0, "savingsPercentage": 0}}
            },
            "sageMakerSavingsPlans": {
                "configuration": {"accountScope": "", "hourlyCommitment": "", "paymentOption": "", "term": ""},
                "costCalculation": {"pricing": {"estimatedMonthlyCommitment": 0, "estimatedOnDemandCost": 0, "monthlySavingsPlansEligibleCost": 0, "savingsPercentage": 0}}
            }
          }
      Handler: "index.lambda_handler"
      MemorySize: 2688
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          BUCKET_NAME: !Ref DestinationBucket
          PREFIX: !Ref CFDataName
          ROLENAME: !Ref ManagementRoleName
          DETAIL_SM_ARN: !Sub 'arn:aws:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${ResourcePrefix}${CFDataName}-detail-StateMachine'
          DETAIL_THROTTLE: "250"
          NEED_DETAILED: "true"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89 # Lambda functions should be deployed inside a VPC
            reason: "No need for VPC in this case"
          - id: W92 #  Lambda functions should define ReservedConcurrentExecutions to reserve simultaneous executions
            reason: "No need for simultaneous execution"

  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${LambdaFunction}"
      RetentionInDays: 60

  CrawlerCostOptimizationHub:
    Type: AWS::Glue::Crawler
    Properties:
      Name: !Sub '${ResourcePrefix}${CFDataName}-summary-Crawler'
      Role: !Ref GlueRoleARN
      DatabaseName: !Ref DatabaseName
      Targets:
        S3Targets:
          - Path: !Sub "s3://${DestinationBucket}/${CFDataName}/${CFDataName}-summary-data/"
      Configuration: |
        {
          "Version": 1.0,
          "CrawlerOutput": {
            "Partitions": {
              "AddOrUpdateBehavior": "InheritFromTable"
            }
          }
        }
  CrawlerCostOptimizationHubDetail:
    Type: AWS::Glue::Crawler
    Properties:
      Name: !Sub '${ResourcePrefix}${CFDataName}-detail-Crawler'
      Role: !Ref GlueRoleARN
      DatabaseName: !Ref DatabaseName
      Targets:
        S3Targets:
          - Path: !Sub "s3://${DestinationBucket}/${CFDataName}/${CFDataName}-detail-data/"
      Configuration: |
        {
          "Version": 1.0,
          "CrawlerOutput": {
            "Partitions": {
              "AddOrUpdateBehavior": "InheritFromTable"
            }
          }
        }

  CostOptimizationHubDetailTable:
    Type: AWS::Glue::Table
    Properties:
      CatalogId: !Ref "AWS::AccountId"
      DatabaseName: !Ref DatabaseName
      TableInput:
        Name: !Join ['_', !Split [ '-', !Sub "${CFDataName}_detail_data" ]]
        Owner: owner
        Retention: 0
        TableType: EXTERNAL_TABLE
        Parameters:
          EXTERNAL: 'TRUE'
          UPDATED_BY_CRAWLER: !Sub '${ResourcePrefix}${CFDataName}-detail-Crawler'
          averageRecordSize: '26673'
          classification: json
          compressionType: none
          typeOfData: file
        PartitionKeys:
          - Name: payer_id
            Type: string
          - Name: year
            Type: string
          - Name: month
            Type: string
          - Name: day
            Type: string
        StorageDescriptor:
          BucketColumns: []
          InputFormat: org.apache.hadoop.mapred.TextInputFormat
          Location: !Sub "s3://${DestinationBucket}/${CFDataName}/${CFDataName}-detail-data/"
          OutputFormat: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
          SerdeInfo:
            Parameters:
              paths: accountId,actionType,costCalculationLookbackPeriodInDays,currencyCode,currentResourceDetails,currentResourceType,estimatedMonthlyCost,estimatedMonthlySavings,estimatedSavingsOverCostCalculationLookbackPeriod,estimatedSavingsPercentage,implementationEffort,lastRefreshTimestamp,recommendationId,recommendationLookbackPeriodInDays,recommendedResourceDetails,recommendedResourceType,region,resourceArn,resourceId,restartNeeded,rollbackPossible,source,tags
              serialization.format: '1'
            SerializationLibrary: org.openx.data.jsonserde.JsonSerDe
          StoredAsSubDirectories: false
          Columns:
          - Name: accountid
            Type: string
          - Name: actiontype
            Type: string
          - Name: costcalculationlookbackperiodindays
            Type: int
          - Name: currencycode
            Type: string
          - Name: currentresourcedetails
            Type: struct<computesavingsplans:struct<configuration:struct<accountscope:string,hourlycommitment:string,paymentoption:string,term:string>,costcalculation:struct<pricing:struct<estimatedmonthlycommitment:double,estimatedondemandcost:double,monthlysavingsplanseligiblecost:double,savingspercentage:double>>>,ebsvolume:struct<configuration:struct<attachmentstate:string,performance:struct<iops:double,throughput:double>,storage:struct<sizeingb:double,type:string>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,ec2autoscalinggroup:struct<configuration:struct<instance:struct<type:string>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,ec2instance:struct<configuration:struct<instance:struct<type:string>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,ec2instancesavingsplans:struct<configuration:struct<accountscope:string,hourlycommitment:string,instancefamily:string,paymentoption:string,savingsplansregion:string,term:string>,costcalculation:struct<pricing:struct<estimatedmonthlycommitment:double,estimatedondemandcost:double,monthlysavingsplanseligiblecost:double,savingspercentage:double>>>,ec2reservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancefamily:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,offeringclass:string,paymentoption:string,platform:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,tenancy:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,ecsservice:struct<configuration:struct<compute:struct<architecture:string,memorysizeinmb:int,platform:string,vcpu:double>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,elasticachereservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancefamily:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,lambdafunction:struct<configuration:struct<compute:struct<architecture:string,memorysizeinmb:int,platform:string,vcpu:double>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,opensearchreservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,rdsreservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,databaseedition:string,databaseengine:string,deploymentoption:string,instancefamily:string,instancetype:string,licensemodel:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,redshiftreservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancefamily:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,sagemakersavingsplans:struct<configuration:struct<accountscope:string,hourlycommitment:string,paymentoption:string,term:string>,costcalculation:struct<pricing:struct<estimatedmonthlycommitment:double,estimatedondemandcost:double,monthlysavingsplanseligiblecost:double,savingspercentage:double>>>>
          - Name: currentresourcetype
            Type: string
          - Name: estimatedmonthlycost
            Type: double
          - Name: estimatedmonthlysavings
            Type: double
          - Name: estimatedsavingsovercostcalculationlookbackperiod
            Type: double
          - Name: estimatedsavingspercentage
            Type: double
          - Name: implementationeffort
            Type: string
          - Name: lastrefreshtimestamp
            Type: string
          - Name: recommendationid
            Type: string
          - Name: recommendationlookbackperiodindays
            Type: int
          - Name: recommendedresourcedetails
            Type: struct<computesavingsplans:struct<configuration:struct<accountscope:string,hourlycommitment:string,paymentoption:string,term:string>,costcalculation:struct<pricing:struct<estimatedmonthlycommitment:double,estimatedondemandcost:double,monthlysavingsplanseligiblecost:double,savingspercentage:double>>>,ebsvolume:struct<configuration:struct<attachmentstate:string,performance:struct<iops:double,throughput:double>,storage:struct<sizeingb:double,type:string>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,ec2autoscalinggroup:struct<configuration:struct<instance:struct<type:string>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,ec2instance:struct<configuration:struct<instance:struct<type:string>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,ec2instancesavingsplans:struct<configuration:struct<accountscope:string,hourlycommitment:string,instancefamily:string,paymentoption:string,savingsplansregion:string,term:string>,costcalculation:struct<pricing:struct<estimatedmonthlycommitment:double,estimatedondemandcost:double,monthlysavingsplanseligiblecost:double,savingspercentage:double>>>,ec2reservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancefamily:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,offeringclass:string,paymentoption:string,platform:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,tenancy:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,ecsservice:struct<configuration:struct<compute:struct<architecture:string,memorysizeinmb:int,platform:string,vcpu:double>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,elasticachereservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancefamily:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,lambdafunction:struct<configuration:struct<compute:struct<architecture:string,memorysizeinmb:int,platform:string,vcpu:double>>,costcalculation:struct<pricing:struct<estimatedcostafterdiscounts:double,estimatedcostbeforediscounts:double,estimateddiscounts:struct<otherdiscount:double,reservedinstancesdiscount:double,savingsplansdiscount:double>,estimatednetunusedamortizedcommitments:double>,usages:array<struct<operation:string,productcode:string,unit:string,usageamount:double,usagetype:string>>>>,opensearchreservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,rdsreservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,databaseedition:string,databaseengine:string,deploymentoption:string,instancefamily:string,instancetype:string,licensemodel:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,redshiftreservedinstances:struct<configuration:struct<accountscope:string,currentgeneration:string,instancefamily:string,instancetype:string,monthlyrecurringcost:string,normalizedunitstopurchase:string,numberofinstancestopurchase:string,paymentoption:string,reservedinstancesregion:string,service:string,sizeflexeligible:string,term:string,upfrontcost:string>,costcalculation:struct<pricing:struct<estimatedmonthlyamortizedreservationcost:double,estimatedondemandcost:double,monthlyreservationeligiblecost:double,savingspercentage:double>>>,sagemakersavingsplans:struct<configuration:struct<accountscope:string,hourlycommitment:string,paymentoption:string,term:string>,costcalculation:struct<pricing:struct<estimatedmonthlycommitment:double,estimatedondemandcost:double,monthlysavingsplanseligiblecost:double,savingspercentage:double>>>>
          - Name: recommendedresourcetype
            Type: string
          - Name: region
            Type: string
          - Name: resourcearn
            Type: string
          - Name: resourceid
            Type: string
          - Name: restartneeded
            Type: string
          - Name: rollbackpossible
            Type: string
          - Name: source
            Type: string
          - Name: tags
            Type: array<struct<key:string,value:string>>

  StepFunctionCostOptimizationHub:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${ResourcePrefix}${CFDataName}-StateMachine'
      StateMachineType: STANDARD
      RoleArn: !Ref StepFunctionExecutionRoleARN
      DefinitionS3Location:
        Bucket: !Ref CodeBucket
        Key: !Ref StepFunctionTemplate
      DefinitionSubstitutions:
        AccountCollectorLambdaARN: !Ref AccountCollectorLambdaARN
        ModuleLambdaARN: !GetAtt LambdaFunction.Arn
        Crawlers: !Sub '["${ResourcePrefix}${CFDataName}-summary-Crawler"]'
        CollectionType: "Payers" #TODO: use delegated account instead of management
        Params: ''
        Module: !Ref CFDataName
        DeployRegion: !Ref AWS::Region
        Account: !Ref AWS::AccountId
        Prefix: !Ref ResourcePrefix
  RefreshScheduleCostOptimizationHub:
    Type: AWS::Scheduler::Schedule
    Properties:
      Description: !Sub 'Scheduler for the ODC ${CFDataName} CostOptimizationHub module'
      Name: !Sub '${ResourcePrefix}${CFDataName}-RefreshSchedule'
      ScheduleExpression: !Ref Schedule
      State: ENABLED
      FlexibleTimeWindow:
        MaximumWindowInMinutes: 30
        Mode: 'FLEXIBLE'
      Target:
        Arn: !GetAtt StepFunctionCostOptimizationHub.Arn
        RoleArn: !Ref SchedulerExecutionRoleARN

  StepFunctionCostOptimizationHubDetail:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${ResourcePrefix}${CFDataName}-detail-StateMachine'
      StateMachineType: STANDARD
      RoleArn: !Ref StepFunctionExecutionRoleARN
      DefinitionString: |
        {
          "Comment": "Collects individual Cost Optimization Hub recommendations",
          "StartAt": "DetailProcessor Map",
          "States": {
            "DetailProcessor Map": {
              "Type": "Map",
              "ItemProcessor": {
                "ProcessorConfig": {
                  "Mode": "DISTRIBUTED",
                  "ExecutionType": "STANDARD"
                },
                "StartAt": "DetailLambda Invoke",
                "States": {
                  "DetailLambda Invoke": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::lambda:invoke",
                    "OutputPath": "$.Payload",
                    "Parameters": {
                      "Payload.$": "$",
                      "FunctionName": "${ModuleLambdaARN}"
                    },
                    "Retry": [
                      {
                        "ErrorEquals": [
                          "Lambda.ServiceException",
                          "Lambda.AWSLambdaException",
                          "Lambda.SdkClientException",
                          "Lambda.TooManyRequestsException"
                        ],
                        "IntervalSeconds": 1,
                        "MaxAttempts": 3,
                        "BackoffRate": 2
                      }
                    ],
                    "End": true
                  }
                }
              },
              "Label": "DetailProcessorMap",
              "MaxConcurrency": ${MaxConcurrentBatches},
              "ItemReader": {
                "Resource": "arn:aws:states:::s3:getObject",
                "ReaderConfig": {
                  "InputType": "CSV",
                  "CSVHeaderLocation": "FIRST_ROW"
                },
                "Parameters": {
                  "Bucket.$": "$.bucket",
                  "Key.$": "$.file"
                }
              },
              "ItemBatcher": {
                "MaxItemsPerBatch": ${ItemsPerBatch},
                "BatchInput": {
                  "account.$": "$.account"
                }
              },
              "Next": "CrawlerStepFunctionStartExecution"
            },
            "CrawlerStepFunctionStartExecution": {
              "Type": "Task",
              "Resource": "arn:aws:states:::states:startExecution.sync:2",
              "Parameters": {
                "StateMachineArn": "arn:aws:states:${DeployRegion}:${Account}:stateMachine:${Prefix}CrawlerExecution-StateMachine",
                "Input": {
                  "crawlers": ${Crawlers}
                }
              },
              "End": true
            }
          },
          "TimeoutSeconds": 3600
        }
      DefinitionSubstitutions:
        AccountCollectorLambdaARN: !Ref AccountCollectorLambdaARN
        ModuleLambdaARN: !GetAtt LambdaFunction.Arn
        Crawlers: !Sub '["${ResourcePrefix}${CFDataName}-detail-Crawler"]'
        CollectionType: "Payers"
        Params: ''
        Module: !Ref CFDataName
        DeployRegion: !Ref AWS::Region
        Account: !Ref AWS::AccountId
        Prefix: !Ref ResourcePrefix
        ItemsPerBatch: 1000
        MaxConcurrentBatches: 10
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E2532 #Passing a dynamic structure for crawlers input into the template as a DefinitionSubstitution

  AnalyticsExecutor:
    Type: Custom::LambdaAnalyticsExecutor
    Properties:
      ServiceToken: !Ref LambdaAnalyticsARN
      Name: !Ref CFDataName
